// @temporal-cortex/truth-engine — WASM-powered RRULE expansion, conflict
// detection, and free/busy computation for Node.js.
//
// This module loads the WASM binary compiled from the truth-engine-wasm Rust
// crate. The WASM bindings are generated by wasm-bindgen as CommonJS (.cjs),
// but this package uses ESM ("type": "module" in package.json). We bridge the
// two module systems using Node's createRequire().
//
// Build chain:
//   truth-engine (Rust) -> truth-engine-wasm (wasm-bindgen) -> truth-engine-js (this wrapper)

import { createRequire } from "module";
const require = createRequire(import.meta.url);

// Load the WASM-generated Node.js bindings (.cjs for CommonJS/ESM compat)
const wasm = require("../wasm/truth_engine_wasm.cjs") as {
  expandRRule: (
    rrule: string,
    dtstart: string,
    duration_minutes: number,
    timezone: string,
    until?: string,
    max_count?: number,
  ) => string;
  findConflicts: (events_a_json: string, events_b_json: string) => string;
  findFreeSlots: (events_json: string, window_start: string, window_end: string) => string;
  mergeAvailability: (streams_json: string, window_start: string, window_end: string, opaque: boolean) => string;
  findFirstFreeAcross: (streams_json: string, window_start: string, window_end: string, min_duration_minutes: number) => string;
};

// ---------------------------------------------------------------------------
// Public types
// ---------------------------------------------------------------------------

export interface TimeRange {
  start: string;
  end: string;
}

export interface Conflict {
  event_a: TimeRange;
  event_b: TimeRange;
  overlap_minutes: number;
}

export interface FreeSlot {
  start: string;
  end: string;
  duration_minutes: number;
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Expand an RFC 5545 RRULE into concrete event instances.
 *
 * @param rrule - RFC 5545 recurrence rule (e.g., "FREQ=DAILY;COUNT=3")
 * @param dtstart - Local datetime for the first occurrence (e.g., "2026-02-17T14:00:00")
 * @param durationMinutes - Duration of each instance in minutes
 * @param timezone - IANA timezone (e.g., "America/Los_Angeles")
 * @param until - Optional end boundary (local datetime string)
 * @param maxCount - Optional maximum number of instances to generate
 * @returns Array of {start, end} objects with RFC 3339 datetime strings
 */
export function expandRRule(
  rrule: string,
  dtstart: string,
  durationMinutes: number,
  timezone: string,
  until?: string,
  maxCount?: number,
): TimeRange[] {
  const json = wasm.expandRRule(
    rrule,
    dtstart,
    durationMinutes,
    timezone,
    until ?? undefined,
    maxCount ?? undefined,
  );
  return JSON.parse(json);
}

/**
 * Find all pairwise conflicts (overlapping time ranges) between two event lists.
 *
 * @param eventsA - First list of events
 * @param eventsB - Second list of events
 * @returns Array of conflict objects with event_a, event_b, and overlap_minutes
 */
export function findConflicts(
  eventsA: TimeRange[],
  eventsB: TimeRange[],
): Conflict[] {
  const json = wasm.findConflicts(JSON.stringify(eventsA), JSON.stringify(eventsB));
  return JSON.parse(json);
}

/**
 * Find free time slots within a given window, given a list of busy events.
 *
 * @param events - List of busy events
 * @param windowStart - Start of the search window (ISO 8601 datetime)
 * @param windowEnd - End of the search window (ISO 8601 datetime)
 * @returns Array of free slot objects with start, end, and duration_minutes
 */
export function findFreeSlots(
  events: TimeRange[],
  windowStart: string,
  windowEnd: string,
): FreeSlot[] {
  const json = wasm.findFreeSlots(JSON.stringify(events), windowStart, windowEnd);
  return JSON.parse(json);
}

// ---------------------------------------------------------------------------
// Multi-stream availability types
// ---------------------------------------------------------------------------

export interface EventStream {
  stream_id: string;
  events: TimeRange[];
}

export interface BusyBlock {
  start: string;
  end: string;
  source_count: number;
}

export interface UnifiedAvailability {
  busy: BusyBlock[];
  free: FreeSlot[];
  window_start: string;
  window_end: string;
  privacy: string;
}

// ---------------------------------------------------------------------------
// Multi-stream availability API
// ---------------------------------------------------------------------------

/**
 * Merge N event streams into unified availability within a time window.
 *
 * This is the core of the "Unified Availability Graph" — it computes a
 * single source of truth for a user's availability across all their calendars.
 *
 * @param streams - Array of event streams (from different calendars/providers)
 * @param windowStart - Start of the analysis window (ISO 8601 datetime)
 * @param windowEnd - End of the analysis window (ISO 8601 datetime)
 * @param opaque - If true, hide source counts in busy blocks (privacy mode). Default: true.
 * @returns Unified availability with busy blocks and free slots
 */
export function mergeAvailability(
  streams: EventStream[],
  windowStart: string,
  windowEnd: string,
  opaque: boolean = true,
): UnifiedAvailability {
  const json = wasm.mergeAvailability(JSON.stringify(streams), windowStart, windowEnd, opaque);
  return JSON.parse(json);
}

/**
 * Find the first free slot of at least `minDurationMinutes` across N merged
 * event streams.
 *
 * @param streams - Array of event streams
 * @param windowStart - Start of the search window (ISO 8601 datetime)
 * @param windowEnd - End of the search window (ISO 8601 datetime)
 * @param minDurationMinutes - Minimum slot duration in minutes
 * @returns The first qualifying free slot, or null if none found
 */
export function findFirstFreeAcross(
  streams: EventStream[],
  windowStart: string,
  windowEnd: string,
  minDurationMinutes: number,
): FreeSlot | null {
  const json = wasm.findFirstFreeAcross(JSON.stringify(streams), windowStart, windowEnd, minDurationMinutes);
  return JSON.parse(json);
}
