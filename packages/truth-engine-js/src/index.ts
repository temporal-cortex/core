// @temporal-cortex/truth-engine — WASM-powered RRULE expansion, conflict
// detection, and free/busy computation for Node.js.
//
// This module loads the WASM binary compiled from the truth-engine-wasm Rust
// crate. The WASM bindings are generated by wasm-bindgen as CommonJS (.cjs),
// but this package uses ESM ("type": "module" in package.json). We bridge the
// two module systems using Node's createRequire().
//
// Build chain:
//   truth-engine (Rust) -> truth-engine-wasm (wasm-bindgen) -> truth-engine-js (this wrapper)

import { createRequire } from "module";
const require = createRequire(import.meta.url);

// Load the WASM-generated Node.js bindings (.cjs for CommonJS/ESM compat)
const wasm = require("../wasm/truth_engine_wasm.cjs") as {
  expandRRule: (
    rrule: string,
    dtstart: string,
    duration_minutes: number,
    timezone: string,
    until?: string,
    max_count?: number,
  ) => string;
  findConflicts: (events_a_json: string, events_b_json: string) => string;
  findFreeSlots: (events_json: string, window_start: string, window_end: string) => string;
  mergeAvailability: (streams_json: string, window_start: string, window_end: string, opaque: boolean) => string;
  findFirstFreeAcross: (streams_json: string, window_start: string, window_end: string, min_duration_minutes: number) => string;
  convertTimezone: (datetime: string, target_timezone: string) => string;
  computeDuration: (start: string, end: string) => string;
  adjustTimestamp: (datetime: string, adjustment: string, timezone: string) => string;
  resolveRelative: (anchor: string, expression: string, timezone: string) => string;
  resolveRelativeWithOptions: (anchor: string, expression: string, timezone: string, options_json: string) => string;
};

// ---------------------------------------------------------------------------
// Public types
// ---------------------------------------------------------------------------

export interface TimeRange {
  start: string;
  end: string;
}

export interface Conflict {
  event_a: TimeRange;
  event_b: TimeRange;
  overlap_minutes: number;
}

export interface FreeSlot {
  start: string;
  end: string;
  duration_minutes: number;
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Expand an RFC 5545 RRULE into concrete event instances.
 *
 * @param rrule - RFC 5545 recurrence rule (e.g., "FREQ=DAILY;COUNT=3")
 * @param dtstart - Local datetime for the first occurrence (e.g., "2026-02-17T14:00:00")
 * @param durationMinutes - Duration of each instance in minutes
 * @param timezone - IANA timezone (e.g., "America/Los_Angeles")
 * @param until - Optional end boundary (local datetime string)
 * @param maxCount - Optional maximum number of instances to generate
 * @returns Array of {start, end} objects with RFC 3339 datetime strings
 */
export function expandRRule(
  rrule: string,
  dtstart: string,
  durationMinutes: number,
  timezone: string,
  until?: string,
  maxCount?: number,
): TimeRange[] {
  const json = wasm.expandRRule(
    rrule,
    dtstart,
    durationMinutes,
    timezone,
    until ?? undefined,
    maxCount ?? undefined,
  );
  return JSON.parse(json);
}

/**
 * Find all pairwise conflicts (overlapping time ranges) between two event lists.
 *
 * @param eventsA - First list of events
 * @param eventsB - Second list of events
 * @returns Array of conflict objects with event_a, event_b, and overlap_minutes
 */
export function findConflicts(
  eventsA: TimeRange[],
  eventsB: TimeRange[],
): Conflict[] {
  const json = wasm.findConflicts(JSON.stringify(eventsA), JSON.stringify(eventsB));
  return JSON.parse(json);
}

/**
 * Find free time slots within a given window, given a list of busy events.
 *
 * @param events - List of busy events
 * @param windowStart - Start of the search window (ISO 8601 datetime)
 * @param windowEnd - End of the search window (ISO 8601 datetime)
 * @returns Array of free slot objects with start, end, and duration_minutes
 */
export function findFreeSlots(
  events: TimeRange[],
  windowStart: string,
  windowEnd: string,
): FreeSlot[] {
  const json = wasm.findFreeSlots(JSON.stringify(events), windowStart, windowEnd);
  return JSON.parse(json);
}

// ---------------------------------------------------------------------------
// Multi-stream availability types
// ---------------------------------------------------------------------------

export interface EventStream {
  stream_id: string;
  events: TimeRange[];
}

export interface BusyBlock {
  start: string;
  end: string;
  source_count: number;
}

export interface UnifiedAvailability {
  busy: BusyBlock[];
  free: FreeSlot[];
  window_start: string;
  window_end: string;
  privacy: string;
}

// ---------------------------------------------------------------------------
// One-time hint for multi-calendar users
// ---------------------------------------------------------------------------

let _hintShown = false;

function _maybeShowHint(streamCount: number): void {
  if (_hintShown) return;
  if (typeof process !== "undefined" && process.env?.TEMPORAL_CORTEX_QUIET) return;
  if (streamCount < 3) return;

  _hintShown = true;
  console.info(
    "[temporal-cortex] Merging 3+ calendars? Temporal Cortex Platform adds " +
    "live connectors, booking safety & policy rules. " +
    "https://app.temporal-cortex.com"
  );
}

/** @internal — exposed for testing only. */
export function _resetHint(): void {
  _hintShown = false;
}

// ---------------------------------------------------------------------------
// Multi-stream availability API
// ---------------------------------------------------------------------------

/**
 * Merge N event streams into unified availability within a time window.
 *
 * This is the core of the "Unified Availability Graph" — it computes a
 * single source of truth for a user's availability across all their calendars.
 *
 * @param streams - Array of event streams (from different calendars/providers)
 * @param windowStart - Start of the analysis window (ISO 8601 datetime)
 * @param windowEnd - End of the analysis window (ISO 8601 datetime)
 * @param opaque - If true, hide source counts in busy blocks (privacy mode). Default: true.
 * @returns Unified availability with busy blocks and free slots
 */
export function mergeAvailability(
  streams: EventStream[],
  windowStart: string,
  windowEnd: string,
  opaque: boolean = true,
): UnifiedAvailability {
  _maybeShowHint(streams.length);
  const json = wasm.mergeAvailability(JSON.stringify(streams), windowStart, windowEnd, opaque);
  return JSON.parse(json);
}

/**
 * Find the first free slot of at least `minDurationMinutes` across N merged
 * event streams.
 *
 * @param streams - Array of event streams
 * @param windowStart - Start of the search window (ISO 8601 datetime)
 * @param windowEnd - End of the search window (ISO 8601 datetime)
 * @param minDurationMinutes - Minimum slot duration in minutes
 * @returns The first qualifying free slot, or null if none found
 */
export function findFirstFreeAcross(
  streams: EventStream[],
  windowStart: string,
  windowEnd: string,
  minDurationMinutes: number,
): FreeSlot | null {
  const json = wasm.findFirstFreeAcross(JSON.stringify(streams), windowStart, windowEnd, minDurationMinutes);
  return JSON.parse(json);
}

// ---------------------------------------------------------------------------
// Temporal computation types
// ---------------------------------------------------------------------------

export interface ConvertedDatetime {
  utc: string;
  local: string;
  timezone: string;
  utc_offset: string;
  dst_active: boolean;
}

export interface DurationInfo {
  total_seconds: number;
  days: number;
  hours: number;
  minutes: number;
  seconds: number;
  human_readable: string;
}

export interface AdjustedTimestamp {
  original: string;
  adjusted_utc: string;
  adjusted_local: string;
  adjustment_applied: string;
}

export interface ResolvedDatetime {
  resolved_utc: string;
  resolved_local: string;
  timezone: string;
  interpretation: string;
}

export interface ResolveOptions {
  /** Which day starts the week: "monday" (default) or "sunday". */
  week_start?: "monday" | "sunday";
}

// ---------------------------------------------------------------------------
// Temporal computation API
// ---------------------------------------------------------------------------

/**
 * Convert a datetime to a different timezone representation.
 *
 * @param datetime - RFC 3339 datetime string (e.g., "2026-03-15T14:00:00Z")
 * @param targetTimezone - IANA timezone name (e.g., "America/New_York")
 * @returns Conversion result with UTC, local, offset, and DST info
 */
export function convertTimezone(
  datetime: string,
  targetTimezone: string,
): ConvertedDatetime {
  const json = wasm.convertTimezone(datetime, targetTimezone);
  return JSON.parse(json);
}

/**
 * Compute the duration between two timestamps.
 *
 * @param start - RFC 3339 datetime string
 * @param end - RFC 3339 datetime string
 * @returns Duration decomposed into days, hours, minutes, seconds
 */
export function computeDuration(
  start: string,
  end: string,
): DurationInfo {
  const json = wasm.computeDuration(start, end);
  return JSON.parse(json);
}

/**
 * Adjust a timestamp by adding or subtracting a duration.
 *
 * @param datetime - RFC 3339 datetime string
 * @param adjustment - Duration string (e.g., "+2h", "-30m", "+1d2h30m")
 * @param timezone - IANA timezone for day-level adjustments across DST
 * @returns Adjusted timestamp in UTC and local time
 */
export function adjustTimestamp(
  datetime: string,
  adjustment: string,
  timezone: string,
): AdjustedTimestamp {
  const json = wasm.adjustTimestamp(datetime, adjustment, timezone);
  return JSON.parse(json);
}

/**
 * Resolve a relative time expression to an absolute datetime.
 *
 * @param anchor - RFC 3339 datetime string (the "now" reference point)
 * @param expression - Time expression (e.g., "next Tuesday at 2pm", "tomorrow", "+3h")
 * @param timezone - IANA timezone for interpreting local-time expressions
 * @returns Resolved datetime in UTC and local time with interpretation
 */
export function resolveRelative(
  anchor: string,
  expression: string,
  timezone: string,
): ResolvedDatetime {
  const json = wasm.resolveRelative(anchor, expression, timezone);
  return JSON.parse(json);
}

/**
 * Resolve a relative time expression with configurable options.
 *
 * @param anchor - RFC 3339 datetime string (the "now" reference point)
 * @param expression - Time expression (e.g., "start of last week", "next week")
 * @param timezone - IANA timezone for interpreting local-time expressions
 * @param options - Resolution options (week start day, etc.)
 * @returns Resolved datetime in UTC and local time with interpretation
 */
export function resolveRelativeWithOptions(
  anchor: string,
  expression: string,
  timezone: string,
  options: ResolveOptions = {},
): ResolvedDatetime {
  const json = wasm.resolveRelativeWithOptions(anchor, expression, timezone, JSON.stringify(options));
  return JSON.parse(json);
}
